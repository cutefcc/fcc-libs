{"version":3,"file":"index.cjs","sources":["../lib/useImmer.ts","../lib/useMountedState.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport produce, { freeze, Draft } from \"immer\";\nexport type DraftFunction<S> = (draft: Draft<S>) => void;\nexport type Updater<S> = (update: S | DraftFunction<S>) => void;\nexport type ImmerHooks<S> = [S, Updater<S>];\n// 函数签名-用来限制具体的实现-签名就是对外的外衣，一般写库会这样搞   【要么写函数签名，要么就写到函数实现里面去】\n// 函数签名 可以类比 interface         class implements\n/*interface A {\n    log(str: string): string;\n}\nclass B implements A {\n    log(str: string) {\n        return str;\n    }\n}*/\nexport function useImmer<S = unknown>(initValue: S | (() => S)): ImmerHooks<S>;\n\n// 函数实现\nexport function useImmer(initValue: unknown) {\n    const [val, setVal] = useState(freeze(typeof initValue === 'function' ? initValue() : initValue, true));\n    // useCallback 的原理是把函数搞到全局，避免传递给子组件时导致memo不生效\n    return [val, useCallback((update) => {\n        if (typeof update === 'function') {\n            setVal(produce(update));\n        } else {\n            setVal(freeze(update));\n        }\n    }, [])];\n}\n\n","import {useRef, useEffect, useCallback} from 'react';\n\nexport function useMountedState() {\n    const mounted = useRef<boolean>(false);\n    const getMounted = useCallback(() => mounted.current, []);\n    useEffect(() => {\n        mounted.current = true;\n        return () => {\n            mounted.current = false;\n        }\n    }, [])\n    return getMounted;\n}\n"],"names":["initValue","useState","freeze","setVal","useCallback","update","produce","mounted","useRef","getMounted","current","useEffect"],"mappings":"oKAkByBA,GACrB,MAAsBC,WAASC,SAA4B,mBAAdF,EAA2BA,IAAcA,GAAW,IAArFG,OAEZ,MAAO,MAAMC,cAAY,SAACC,GAElBF,EADkB,mBAAXE,EACAC,UAAQD,GAERH,SAAOG,KAEnB,yCCxBH,IAAME,EAAUC,UAAgB,GAC1BC,EAAaL,cAAY,kBAAMG,EAAQG,SAAS,IAOtD,OANAC,YAAU,WAEN,OADAJ,EAAQG,SAAU,aAEdH,EAAQG,SAAU,IAEvB,IACID"}