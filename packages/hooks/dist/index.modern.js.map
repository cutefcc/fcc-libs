{"version":3,"file":"index.modern.js","sources":["../lib/useImmer.ts","../lib/useMountedState.ts"],"sourcesContent":["import { useCallback, useState } from 'react';\nimport produce, { freeze, Draft } from \"immer\";\nexport type DraftFunction<S> = (draft: Draft<S>) => void;\nexport type Updater<S> = (update: S | DraftFunction<S>) => void;\nexport type ImmerHooks<S> = [S, Updater<S>];\n// 函数签名-用来限制具体的实现-签名就是对外的外衣，一般写库会这样搞   【要么写函数签名，要么就写到函数实现里面去】\n// 函数签名 可以类比 interface         class implements\n/*interface A {\n    log(str: string): string;\n}\nclass B implements A {\n    log(str: string) {\n        return str;\n    }\n}*/\nexport function useImmer<S = unknown>(initValue: S | (() => S)): ImmerHooks<S>;\n\n// 函数实现\nexport function useImmer(initValue: unknown) {\n    const [val, setVal] = useState(freeze(typeof initValue === 'function' ? initValue() : initValue, true));\n    // useCallback 的原理是把函数搞到全局，避免传递给子组件时导致memo不生效\n    return [val, useCallback((update) => {\n        if (typeof update === 'function') {\n            setVal(produce(update));\n        } else {\n            setVal(freeze(update));\n        }\n    }, [])];\n}\n\n","import {useRef, useEffect, useCallback} from 'react';\n\nexport function useMountedState() {\n    const mounted = useRef<boolean>(false);\n    const getMounted = useCallback(() => mounted.current, []);\n    useEffect(() => {\n        mounted.current = true;\n        return () => {\n            mounted.current = false;\n        }\n    }, [])\n    return getMounted;\n}\n"],"names":["useImmer","initValue","val","setVal","useState","freeze","useCallback","update","produce","useMountedState","mounted","useRef","getMounted","current","useEffect"],"mappings":"wHAkBgBA,EAASC,GACrB,MAAOC,EAAKC,GAAUC,EAASC,EAA4B,mBAAdJ,EAA2BA,IAAcA,GAAW,IAEjG,MAAO,CAACC,EAAKI,EAAaC,IAElBJ,EADkB,mBAAXI,EACAC,EAAQD,GAERF,EAAOE,KAEnB,cCzBSE,IACZ,MAAMC,EAAUC,GAAgB,GAC1BC,EAAaN,EAAY,IAAMI,EAAQG,QAAS,IAOtD,OANAC,EAAU,KACNJ,EAAQG,SAAU,EACX,KACHH,EAAQG,SAAU,IAEvB,IACID"}